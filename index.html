<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>AR Path Visualization</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.rawgit.com/jeromeetienne/AR.js/2.2.0/aframe/build/aframe-ar.js"></script>
    <script src="https://unpkg.com/three@0.142.0/build/three.min.js"></script>
</head>

<body style="margin : 0px; overflow: hidden;">
    <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;" vr-mode-ui="enabled: false;">
        <a-marker type="barcode" value="0">
            <a-entity position="0 0 0">
                <a-camera gps-camera rotation-reader></a-camera>
            </a-entity>
        </a-marker>

        <!-- Define the path geometry -->
        <a-entity id="path" line="color: red; opacity: 0.8"></a-entity>

        <a-entity gps-entity-place="latitude: 35.1910006; longitude: 132.5008423">
            <a-sphere radius="0.2" color="blue"></a-sphere>
        </a-entity>
        <a-entity gps-entity-place="latitude: 35.1911951; longitude: 132.5010555">
            <a-sphere radius="0.2" color="blue"></a-sphere>
        </a-entity>
        <!-- Add more entities for additional points -->

        <script>
            AFRAME.registerComponent("gps-camera", {
                schema: {
                    rotationReader: { default: false },
                },
                init: function () {
                    this.bindMethods();
                    this.addEventListeners();
                    this.setupARCamera();
                },
                bindMethods: function () {
                    this.setupARCamera = this.setupARCamera.bind(this);
                    this.onRotationUpdate = this.onRotationUpdate.bind(this);
                },
                addEventListeners: function () {
                    if (this.data.rotationReader) {
                        window.addEventListener("deviceorientation", this.onRotationUpdate);
                    }
                },
                setupARCamera: function () {
                    const cameraEl = this.el;
                    const gpsCamera = document.createElement("a-entity");
                    gpsCamera.setAttribute("gps-camera", "");
                    gpsCamera.setAttribute("rotation", "0 0 0");
                    cameraEl.appendChild(gpsCamera);
                    cameraEl.removeAttribute("gps-camera");
                },
                onRotationUpdate: function (event) {
                    const cameraEl = this.el;
                    const alpha = event.alpha;
                    const beta = event.beta;
                    const gamma = event.gamma;
                    cameraEl.setAttribute("rotation", `${gamma} ${alpha} ${-beta}`);
                },
            });

            AFRAME.registerComponent("gps-entity-place", {
                schema: {
                    latitude: { type: "number" },
                    longitude: { type: "number" },
                },
                init: function () {
                    const { latitude, longitude } = this.data;
                    const entity = this.el;

                    if (latitude && longitude) {
                        navigator.geolocation.getCurrentPosition(
                            (position) => {
                                this.updatePosition(position);
                            },
                            (error) => {
                                console.error(error);
                            }
                        );
                    }
                },
                updatePosition: function (position) {
                    const { latitude, longitude } = this.data;
                    const { coords } = position;
                    const { latitude: currentLatitude, longitude: currentLongitude } = coords;
                    const distance = this.calculateDistance(
                        currentLatitude,
                        currentLongitude,
                        latitude,
                        longitude
                    );
                    const bearing = this.calculateBearing(
                        currentLatitude,
                        currentLongitude,
                        latitude,
                        longitude
                    );
                    const { x, z } = this.calculatePosition(distance, bearing);
                    const entity = this.el;
                    entity.setAttribute("position", `${x} 0 ${z}`);
                },
                calculateDistance: function (lat1, lon1, lat2, lon2) {
                    const R = 6371; // Radius of the earth in km
                    const dLat = this.deg2rad(lat2 - lat1);
                    const dLon = this.deg2rad(lon2 - lon1);
                    const a =
                        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                        Math.cos(this.deg2rad(lat1)) *
                        Math.cos(this.deg2rad(lat2)) *
                        Math.sin(dLon / 2) *
                        Math.sin(dLon / 2);
                    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                    const d = R * c; // Distance in km
                    return d * 1000; // Return distance in meters
                },
                calculateBearing: function (lat1, lon1, lat2, lon2) {
                    const dLon = this.deg2rad(lon2 - lon1);
                    const y = Math.sin(dLon) * Math.cos(this.deg2rad(lat2));
                    const x =
                        Math.cos(this.deg2rad(lat1)) * Math.sin(this.deg2rad(lat2)) -
                        Math.sin(this.deg2rad(lat1)) *
                        Math.cos(this.deg2rad(lat2)) *
                        Math.cos(dLon);
                    const brng = this.rad2deg(Math.atan2(y, x));
                    return (brng + 360) % 360;
                },
                calculatePosition: function (distance, bearing) {
                    const x = distance * Math.sin(this.deg2rad(bearing));
                    const z = distance * Math.cos(this.deg2rad(bearing));
                    return { x, z };
                },
                deg2rad: function (deg) {
                    return deg * (Math.PI / 180);
                },
                rad2deg: function (rad) {
                    return rad * (180 / Math.PI);
                },
            });

            const main = async () => {
                console.log('main');

                const successCallback = position => {
                    console.log('success', position);
                    staticLoadPlaces().forEach(renderPlace);
                };

                const errorCallback = error => {
                    console.log('error', error);
                    alert(error.message);
                };

                navigator.geolocation.getCurrentPosition(
                    successCallback,
                    errorCallback
                );
            };
            
            window.onload = main;

        </script>
    </a-scene>
</body>

</html>

<!-- <!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>  
    <title>Hello AR.js World! Step2 (dynamic)</title>
  </head>

  <body style="margin: 0; overflow: hidden;">
    <a-scene
      vr-mode-ui="enabled: false;"
      loading-screen="enabled: false;"
      renderer="logarithmicDepthBuffer: true;"
      arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;"
      embedded
    >
      <a-assets>
        <a-asset-item
          id="asset-eevee"
          src="https://daisukesudo.github.io/samples/arjs/step2/assets/eevee.gltf"
        ></a-asset-item>
      </a-assets>

      <a-camera gps-camera rotation-reader></a-camera>
    </a-scene>
    <script src="app.js"></script>
  </body>
</html>
 -->
